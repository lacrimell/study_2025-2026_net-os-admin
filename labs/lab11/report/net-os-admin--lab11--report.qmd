---
## Author
author:
  name: Калашникова Ольга Сергеевна
  email: 1132231846@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчёт по лабораторной работе № 11"
license: "CC BY"
---

# Цель работы

Приобретение практических навыков по настройке удалённого доступа к серверу с помощью SSH.

# Задание

1. Настройте запрет удалённого доступа на сервер по SSH для пользователя root (см.раздел 11.4.1).

2. Настройте разрешение удалённого доступа к серверу по SSH только для пользователей группы vagrant и вашего пользователя (см. раздел 11.4.2).

3. Настройте удалённый доступ к серверу по SSH через порт 2022 (см. раздел 11.4.3).

4. Настройте удалённый доступ к серверу по SSH по ключу (см. раздел 11.4.4).

5. Организуйте SSH-туннель с клиента на сервер, перенаправив локальное соедине-ние с TCP-порта 80 на порт 8080 (см. раздел 11.4.5).

6. Используя удалённое SSH-соединение, выполните с клиента несколько команд насервере (см. раздел 11.4.6).

7. Используя удалённое SSH-соединение, запустите с клиента графическое приложение на сервере (см. раздел 11.4.7).

8. Напишите скрипт для Vagrant, фиксирующий действия по настройке SSH-сервераво внутреннем окружении виртуальной машины server. Соответствующим образом внесите изменения в Vagrantfile (см. раздел 11.4.8)

# Выполнение лабораторной работы

## Запрет удалённого доступа по SSH для пользователя root

На сервере зададим пароль для пользователя root(passwd root) ([рис. @fig-001]).

![Пароль для пользователя root](image/1.png){#fig-001 width=70%}

На сервере в дополнительном терминале запустим мониторинг системных событий (journalctl -x -f) ([рис. @fig-002]).

![Мониторинг системных событий](image/2.png){#fig-002 width=70%}

С клиента попытаемся получить доступ к серверу посредством SSH-соединения через пользователя root: ```ssh root@server.user.net```. При попытке подключения с клиентской машины client.oskalashnikova.net к серверу server.oskalashnikova.net через SSH под пользователем root сначала происходит этап проверки подлинности сервера. Поскольку клиент ранее не подключался к данному серверу, система запрашивает подтверждение подлинности ED25519-ключа сервера с отпечатком SHA256:e8eMV9vV2/LIjH5u55qD351na/8Hx3BM+2+H34TPpNA. После подтверждения пользователем ключ сервера permanently добавляется в список известных хостов для будущих подключений. На следующем этапе система запрашивает пароль пользователя root для аутентификации на сервере. Однако после ввода пароля (который не отображается в терминале) происходит отказ в доступе с сообщением "Permission denied". Пользователю предоставляется вторая попытка ввода пароля, но после повторной неудачной попытки аутентификации сервер разрывает SSH-соединение. В результате доступ к серверу под учетной записью root не был получен. ([рис. @fig-003]).

![Попытка получить доступ к серверу посредством SSH-соединения через пользователя root](image/3.png){#fig-003 width=70%}

На сервере откроем файл /etc/ssh/sshd_config конфигурации sshd для редактирования и запретим вход на сервер пользователю root, установив PermitRootLogin no ([рис. @fig-004]).

![Редактирование файла /etc/ssh/sshd_config](image/4.png){#fig-004 width=70%}

После сохранения изменений в файле конфигурации перезапустите sshd: ```systemctl restart sshd``` ([рис. @fig-005]).

![Перезапуск sshd](image/5.png){#fig-005 width=70%}

Повторим попытку получения доступа с клиента к серверу посредством SSH-соединения через пользователя root при помощи команды ssh root@server. При повторной попытке подключения к серверу через SSH с использованием команды ssh root@server процесс начинается с проверки подлинности хоста. Система обнаруживает, что ключ сервера уже известен под именем server.oskalashnikova.net (записан в файле ~/.ssh/known_hosts на строке 1), но теперь подключение осуществляется по короткому имени server. Это вызывает предупреждение о том, что подлинность хоста server (192.168.1.1) не может быть установлена, поскольку это новое имя для уже известного ключа. Пользователь подтверждает подключение, и имя server добавляется в список известных хостов.

Далее система трижды запрашивает пароль для пользователя root, но каждый раз получает отказ с сообщением "Permission denied". После третьей неудачной попытки система выдает окончательное сообщение об отказе в доступе, указывая, что все методы аутентификации исчерпаны: публичный ключ, методы GSSAPI и парольная аутентификация не сработали.  ([рис. @fig-006]).

![Повторная попытка получить доступ к серверу посредством SSH-соединения через пользователя root](image/6.png){#fig-006 width=70%}

## Ограничение списка пользователей для удалённого доступа по SSH

С клиента попыемся получить доступ к серверу посредством SSH-соединения через пользователя user: ```ssh oskalashnikova@server.oskalashnikova.net```. При подключении к серверу с клиента с использованием команды ssh oskalashnikova@server.oskalashnikova.net происходит успешная аутентификация и установление SSH-соединения. В отличие от предыдущих попыток входа под пользователем root, система сразу запрашивает пароль для пользователя oskalashnikova, и после его ввода доступ предоставляется. Успешное подключение подтверждается информационным сообщением о доступной веб-консоли по адресам https://server:9090/ или https://10.0.2.15:9090/, а также указанием времени последнего входа в систему (Sat Nov 15 10:49:03 2025). Пользователь получает командную строку сервера с приглашением [oskalashnikova@server ~]$, что свидетельствует о полноценном доступе к серверу под учетной записью oskalashnikova. ([рис. @fig-007]).

![Попытка получить доступ к серверу посредством SSH-соединения через пользователя](image/7.png){#fig-007 width=70%}

На сервере откроем файл /etc/ssh/sshd_config конфигурации sshd на редактирование и добавим строку AllowUsers vagrant ([рис. @fig-008]).

![Редактирование файла /etc/ssh/sshd_config](image/8.png){#fig-008 width=70%}

После сохранения изменений в файле конфигурации перезапустим sshd: ```systemctl restart sshd``` ([рис. @fig-009]).

![Перезапуск sshd](image/9.png){#fig-009 width=70%} 

Повторим попытку получения доступа с клиента к серверу посредством SSH-соединения через пользователя user: ```ssh oskalashnikova@server.oskalashnikova.net```. При попытке подключения с сервера на самого себя через SSH по команде ssh oskalashnikova@server.oskalashnikova.net происходит неожиданный отказ в доступе. Сначала система добавляет ключ хоста в список известных, так как он ранее не использовался для этого имени. Однако при вводе пароля пользователя oskalashnikova аутентификация трижды завершается неудачно с сообщением "Permission denied", после чего соединение разрывается. ([рис. @fig-010]).

![Повторная попытка получить доступ к серверу посредством SSH-соединения через пользователя](image/10.png){#fig-010 width=70%}

В файле /etc/ssh/sshd_config конфигурации sshd внесём следующее изменение: AllowUsers vagrant user  ([рис. @fig-011]).

![Редактирование файла /etc/ssh/sshd_config](image/11.png){#fig-011 width=70%}

После сохранения изменений в файле конфигурации перезапустим sshd ([рис. @fig-012]).

![Перезапуск sshd](image/12.png){#fig-012 width=70%} 

Вновь попытаемся получить доступ с клиента к серверу посредством SSH-соединения через пользователя user. При повторной попытке подключения с клиента к серверу через SSH под пользователем oskalashnikova на этот раз происходит успешная аутентификация. После ввода правильного пароля система устанавливает соединение и отображает приветственное сообщение. ([рис. @fig-013]).

![Повторная попытка получить доступ к серверу посредством SSH-соединения через пользователя](image/13.png){#fig-013 width=70%}

## Настройка дополнительных портов для удалённого доступа по SSH

На сервере в файле конфигурации sshd /etc/ssh/sshd_config найдём строку Port и ниже этой строки добавим: Port 22 и Port 2022. Эта запись сообщает процессу sshd о необходимости организации соединения через два разных порта, что даёт гарантию возможности открыть сеансы SSH, даже если была сделана ошибка в конфигурации ([рис. @fig-014]).

![Редактирование файла /etc/ssh/sshd_config](image/14.png){#fig-014 width=70%}

После сохранения изменений в файле конфигурации перезапустим sshd: ```systemctl restart sshd``` ([рис. @fig-015]).

![Перезапуск sshd](image/15.png){#fig-015 width=70%} 

Посмотрим расширенный статус работы sshd: ```systemctl status -l sshd``` ([рис. @fig-016]).

![Расширенный статус работы sshd](image/16.png){#fig-016 width=70%} 

Система должна сообщила об отказе в работе sshd через порт 2022. Анализ системных логов показывает, что основная проблема с запуском SSH-сервера на порту 2022 связана с политикой безопасности SELinux. Система явно сообщает: "SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port 2022" — это означает, что SELinux блокирует привязку SSH-демона к порту 2022 ([рис. @fig-017]).

![Анализ системных логов](image/17.png){#fig-017 width=70%} 

Исправим на сервере метки SELinux к порту 2022: ```semanage port -a -t ssh_port_t -p tcp 2022``` ([рис. @fig-018]).

![Исправление на сервере метки SELinux к порту 2022](image/18.png){#fig-018 width=70%} 

В настройках межсетевого экрана откроем порт 2022 протокола TCP: ```firewall-cmd --add-port=2022/tcp``` , ```firewall-cmd --add-port=2022/tcp --permanent``` ([рис. @fig-019]).

![Открытие порта 2022 протокола TCP](image/19.png){#fig-019 width=70%} 

Вновь перезапустим sshd и посмотрите расширенный статус его работы. Процесс sshd теперь прослушивает два порта. ([рис. @fig-020]).

![Перезапуск sshd](image/20.png){#fig-020 width=70%} 

С клиента попытайемся получить доступ к серверу посредством SSH-соединения через пользователя user (ssh user@server.user.net) ([рис. @fig-021]).

![Доступ к серверу посредством SSH-соединения через пользователя user](image/21.png){#fig-021 width=70%} 

После открытия оболочки пользователя введём sudo -i для получения доступа root. Отлогинимся от root и пользователя на сервере, введя дважды logout ([рис. @fig-022]).

![logout](image/22.png){#fig-022 width=70%} 

Повторим попытку получения доступа с клиента к серверу посредством SSH-соединения через пользователя user, указав порт 2022: ```ssh -p2022 user@server.user.net``` ([рис. @fig-023]).

![Доступ к серверу посредством SSH-соединения через пользователя user через порт 2022](image/23.png){#fig-023 width=70%} 

После открытия оболочки пользователя введём sudo -i для получения доступа root. Отлогинимся от root и пользователя на сервере, введя дважды logout ([рис. @fig-024]).

![logout](image/24.png){#fig-024 width=70%} 

## Настройка удалённого доступа по SSH по ключу

На сервере в конфигурационном файле /etc/ssh/sshd_config зададим параметр,разрешающий аутентификацию по ключу: PubkeyAuthentication yes ([рис. @fig-025]).

![Редактирование файла /etc/ssh/sshd_config](image/25.png){#fig-025 width=70%}

После сохранения изменений в файле конфигурации перезапустим sshd ([рис. @fig-026]).

![Перезапуск sshd](image/26.png){#fig-026 width=70%}

На клиенте сформируем SSH-ключ, введя в терминале под пользователем user ```ssh-keygen``` ([рис. @fig-027]).

![Генерация ключа](image/27.png){#fig-027 width=70%}

Скопируем открытый ключ на сервер, введя на клиенте ```ssh-copy-id user@server.user.net``` ([рис. @fig-028]).

![Копирование открытый ключ на сервер](image/28.png){#fig-028 width=70%}

Попробуем получить доступ с клиента к серверу посредством SSH-соединения ```ssh user@server.user.net```. Отлогинимсяя с сервера, используя комбинацию клавиш Ctrl + d ([рис. @fig-029]).

![Доступ к серверу посредством SSH-соединения](image/29.png){#fig-029 width=70%}

## Организация туннелей SSH, перенаправление TCP-портов

На клиенте посмотрим, запущены ли какие-то службы с протоколом TCP: ```lsof | grep TCP```. Перенаправим порт 80 на server.user.net на порт 8080 на локальной машине ```ssh -fNL 8080:localhost:80``` и  user@server.user.net вновь на клиенте посмотрим, запущены ли какие-то службы с протоколом TCP. После создания SSH-туннеля командой ssh -fNL 8080:localhost:80 на клиенте установилось защищенное соединение с сервером. В результате на клиентской машине появились два слушающих порта localhost:webcache (IPv4 и IPv6), соответствующих порту 8080. Это означает, что туннель успешно создан — весь трафик на локальный порт 8080 теперь перенаправляется через SSH-соединение на порт 80 целевого сервера, обеспечивая безопасный доступ к веб-серверу сервера через локальный интерфейс клиента ([рис. @fig-030]).

![Перенаправление порта 80 на server.user.net на порт 8080 на локальной машине](image/30.png){#fig-030 width=70%}

На клиенте запустим браузер и в адресной строке введём localhost:8080. Отобразилась страница с приветствием «Welcome to the server.user.net server» ([рис. @fig-031]).

![Страница localhost:8080](image/31.png){#fig-031 width=70%}

## Запуск консольных приложений через SSH

На клиенте откроем терминал под пользователем user. Посмотрим с клиента имя узла сервера: ```ssh user@server.user.net hostname.``` ([рис. @fig-032]).

![Посмотрим с клиента имя узла сервера](image/32.png){#fig-032 width=70%}

Посмотрим с клиента список файлов на сервере: ```ssh user@server.user.net ls -Al``` ([рис. @fig-033]).

![Посмотрим с клиента cписок файлов на сервере](image/33.png){#fig-033 width=70%}

Посмотрим с клиента почту на сервере: ```ssh user@server.user.net MAIL=~/Maildir/ mail``` ([рис. @fig-034]).

![Посмотрим с клиента почту на сервере](image/34.png){#fig-034 width=70%}

## Запуск графических приложений через SSH (X11Forwarding)

На сервере в конфигурационном файле /etc/ssh/sshd_config разрешим отображать на локальном клиентском компьютере графические интерфейсы X11 (X11Forwarding yes) ([рис. @fig-035]).

![Редактирование файла /etc/ssh/sshd_config](image/35.png){#fig-035 width=70%}

После сохранения изменения в конфигурационном файле перезапустите sshd ([рис. @fig-036]).

![Перезапуск sshd](image/36.png){#fig-036 width=70%}

Попробуем с клиента удалённо подключиться к серверу и запустить графическое приложение, например firefox (```ssh -YC user@server.user.net firefox```). Настройка X11Forwarding выполнена согласно заданию. В файле /etc/ssh/sshd_config параметры X11Forwarding, X11DisplayOffset и X11UseLocalhost установлены в значение 'yes'. Однако при попытке запуска графического приложения через SSH возникает ошибка 'X11 forwarding request failed on channel 0', что связано с отсутствием графической среды на клиентской машине в минимальной установке CentOS. Все необходимые настройки применены и проверены ([рис. @fig-037]).

![X11](image/37.png){#fig-037 width=70%}

## Внесение изменений в настройки внутреннего окружения виртуальной машины

На виртуальной машине server перейдём в каталог для внесения изменений в настройки внутреннего окружения /vagrant/provision/server/, создадим в нём каталог ssh, в который поместим в соответствующие подкаталоги конфигурационный файл sshd_config ([рис. @fig-038]).

![Перемещение файлов](image/38.png){#fig-038 width=70%}

В каталоге /vagrant/provision/server создадим исполняемый файл ssh.sh ([рис. @fig-039]).

![Исполняемый файл ssh.sh](image/39.png){#fig-039 width=70%}

Открыв его на редактирование, пропишите в нём скрипт ([рис. @fig-040]).

![Скрипт](image/40.png){#fig-040 width=70%}

Для отработки созданного скрипта во время загрузки виртуальной машины server в конфигурационном файле Vagrantfile добавим информацию в разделе конфигурации для сервера ([рис. @fig-041]).

![редактирование файла Vagrantfile](image/41.png){#fig-041 width=70%}

# Выводы

В ходе выполнения лабораторной работы были приобретены практические навыки по настройке удалённого доступа к серверу с помощью SSH.
